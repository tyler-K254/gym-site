/**
 * DevExtreme (esm/__internal/scheduler/workspaces/view_model/m_grouped_data_map_provider.js)
 * Version: 23.2.6
 * Build date: Wed May 01 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import dateUtils from "../../../../core/utils/date";
import {
    dateUtilsTs
} from "../../../core/utils/date";
import {
    isDateAndTimeView
} from "../../../scheduler/r1/utils/index";
import timezoneUtils from "../../m_utils_time_zone";
var toMs = dateUtils.dateToMilliseconds;
export class GroupedDataMapProvider {
    constructor(viewDataGenerator, viewDataMap, completeViewDataMap, viewOptions) {
        this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);
        this.completeViewDataMap = completeViewDataMap;
        this._viewOptions = viewOptions
    }
    getGroupStartDate(groupIndex) {
        var _a, _b, _c;
        var firstRow = this.getFirstGroupRow(groupIndex);
        return null !== (_c = null === (_b = null === (_a = null === firstRow || void 0 === firstRow ? void 0 : firstRow[0]) || void 0 === _a ? void 0 : _a.cellData) || void 0 === _b ? void 0 : _b.startDate) && void 0 !== _c ? _c : null
    }
    getGroupEndDate(groupIndex) {
        var lastRow = this.getLastGroupRow(groupIndex);
        if (lastRow) {
            var lastColumnIndex = lastRow.length - 1;
            var {
                cellData: cellData
            } = lastRow[lastColumnIndex];
            var {
                endDate: endDate
            } = cellData;
            return endDate
        }
    }
    findGroupCellStartDate(groupIndex, startDate, endDate, isFindByDate) {
        var groupData = this.getGroupFromDateTableGroupMap(groupIndex);
        var checkCellStartDate = (rowIndex, columnIndex) => {
            var {
                cellData: cellData
            } = groupData[rowIndex][columnIndex];
            var {
                startDate: secondMin,
                endDate: secondMax
            } = cellData;
            if (isFindByDate) {
                secondMin = dateUtils.trimTime(secondMin);
                secondMax = dateUtils.setToDayEnd(secondMin)
            }
            if (dateUtils.intervalsOverlap({
                    firstMin: startDate,
                    firstMax: endDate,
                    secondMin: secondMin,
                    secondMax: secondMax
                })) {
                return secondMin
            }
        };
        var startDateVerticalSearch = (() => {
            var cellCount = groupData[0].length;
            for (var columnIndex = 0; columnIndex < cellCount; ++columnIndex) {
                for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {
                    var result = checkCellStartDate(rowIndex, columnIndex);
                    if (result) {
                        return result
                    }
                }
            }
        })();
        var startDateHorizontalSearch = (() => {
            for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {
                var row = groupData[rowIndex];
                for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {
                    var result = checkCellStartDate(rowIndex, columnIndex);
                    if (result) {
                        return result
                    }
                }
            }
        })();
        return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch
    }
    findAllDayGroupCellStartDate(groupIndex) {
        var _a, _b, _c;
        var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);
        var cellData = null === (_b = null === (_a = null === groupedData || void 0 === groupedData ? void 0 : groupedData[0]) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b.cellData;
        return null !== (_c = null === cellData || void 0 === cellData ? void 0 : cellData.startDate) && void 0 !== _c ? _c : null
    }
    findCellPositionInMap(cellInfo, isAppointmentRender) {
        var {
            groupIndex: groupIndex,
            startDate: startDate,
            isAllDay: isAllDay,
            index: index
        } = cellInfo;
        var {
            allDayPanelGroupedMap: allDayPanelGroupedMap,
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        var {
            viewOffset: viewOffset
        } = this._viewOptions;
        var rows = isAllDay && !this._viewOptions.isVerticalGrouping ? allDayPanelGroupedMap[groupIndex] ? [allDayPanelGroupedMap[groupIndex]] : [] : dateTableGroupedMap[groupIndex] || [];
        for (var rowIndex = 0; rowIndex < rows.length; rowIndex += 1) {
            var row = rows[rowIndex];
            for (var columnIndex = 0; columnIndex < row.length; columnIndex += 1) {
                var cell = row[columnIndex];
                var originCellData = cell.cellData;
                var cellData = isAppointmentRender ? _extends(_extends({}, originCellData), {
                    startDate: dateUtilsTs.addOffsets(cell.cellData.startDate, [-viewOffset]),
                    endDate: dateUtilsTs.addOffsets(cell.cellData.endDate, [-viewOffset])
                }) : originCellData;
                if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {
                    if (this.isStartDateInCell(startDate, isAllDay, cellData, originCellData)) {
                        return cell.position
                    }
                }
            }
        }
        return
    }
    isStartDateInCell(startDate, inAllDayRow, _ref, _ref2) {
        var {
            startDate: cellStartDate,
            endDate: cellEndDate,
            allDay: cellAllDay
        } = _ref;
        var {
            startDate: originCellStartDate,
            endDate: originCellEndDate
        } = _ref2;
        var {
            viewType: viewType
        } = this._viewOptions;
        var cellSecondIntervalOffset = this.getCellSecondIntervalOffset(originCellStartDate, originCellEndDate);
        var isCellCoversTwoIntervals = 0 !== cellSecondIntervalOffset;
        switch (true) {
            case !isDateAndTimeView(viewType):
            case inAllDayRow && cellAllDay:
                return dateUtils.sameDate(startDate, cellStartDate);
            case !inAllDayRow && !isCellCoversTwoIntervals:
                return startDate >= cellStartDate && startDate < cellEndDate;
            case !inAllDayRow && isCellCoversTwoIntervals:
                return this.isStartDateInTwoIntervalsCell(startDate, cellSecondIntervalOffset, cellStartDate, cellEndDate);
            default:
                return false
        }
    }
    getCellSecondIntervalOffset(cellStartDate, cellEndDate) {
        var nextHourCellStartDate = dateUtilsTs.addOffsets(cellStartDate, [toMs("hour")]);
        var cellTimezoneDiff = timezoneUtils.getDaylightOffset(cellStartDate, cellEndDate);
        var cellNextHourTimezoneDiff = timezoneUtils.getDaylightOffset(cellStartDate, nextHourCellStartDate);
        var isDSTInsideCell = 0 !== cellTimezoneDiff;
        var isWinterTimezoneNextHour = cellNextHourTimezoneDiff < 0;
        return !isDSTInsideCell && isWinterTimezoneNextHour ? Math.abs(cellNextHourTimezoneDiff * toMs("minute")) : 0
    }
    isStartDateInTwoIntervalsCell(startDate, secondIntervalOffset, cellStartDate, cellEndDate) {
        var nextIntervalCellStartDate = dateUtilsTs.addOffsets(cellStartDate, [secondIntervalOffset]);
        var nextIntervalCellEndDate = dateUtilsTs.addOffsets(cellEndDate, [secondIntervalOffset]);
        var isInOriginInterval = startDate >= cellStartDate && startDate < cellEndDate;
        var isInSecondInterval = startDate >= nextIntervalCellStartDate && startDate < nextIntervalCellEndDate;
        return isInOriginInterval || isInSecondInterval
    }
    _isSameGroupIndexAndIndex(cellData, groupIndex, index) {
        return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index)
    }
    getCellsGroup(groupIndex) {
        var {
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        var groupData = dateTableGroupedMap[groupIndex];
        if (groupData) {
            var {
                cellData: cellData
            } = groupData[0][0];
            return cellData.groups
        }
    }
    getCompletedGroupsInfo() {
        var {
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        return dateTableGroupedMap.map(groupData => {
            var firstCell = groupData[0][0];
            var {
                allDay: allDay,
                groupIndex: groupIndex
            } = firstCell.cellData;
            return {
                allDay: allDay,
                groupIndex: groupIndex,
                startDate: this.getGroupStartDate(groupIndex),
                endDate: this.getGroupEndDate(groupIndex)
            }
        }).filter(_ref3 => {
            var {
                startDate: startDate
            } = _ref3;
            return !!startDate
        })
    }
    getGroupIndices() {
        return this.getCompletedGroupsInfo().map(_ref4 => {
            var {
                groupIndex: groupIndex
            } = _ref4;
            return groupIndex
        })
    }
    getGroupFromDateTableGroupMap(groupIndex) {
        var {
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        return dateTableGroupedMap[groupIndex]
    }
    getFirstGroupRow(groupIndex) {
        var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);
        if (groupedData) {
            var {
                cellData: cellData
            } = groupedData[0][0];
            return !cellData.allDay ? groupedData[0] : groupedData[1]
        }
    }
    getLastGroupRow(groupIndex) {
        var {
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        var groupedData = dateTableGroupedMap[groupIndex];
        if (groupedData) {
            var lastRowIndex = groupedData.length - 1;
            return groupedData[lastRowIndex]
        }
    }
    getLastGroupCellPosition(groupIndex) {
        var groupRow = this.getLastGroupRow(groupIndex);
        return null === groupRow || void 0 === groupRow ? void 0 : groupRow[(null === groupRow || void 0 === groupRow ? void 0 : groupRow.length) - 1].position
    }
    getRowCountInGroup(groupIndex) {
        var groupRow = this.getLastGroupRow(groupIndex);
        var cellAmount = groupRow.length;
        var lastCellData = groupRow[cellAmount - 1].cellData;
        var lastCellIndex = lastCellData.index;
        return (lastCellIndex + 1) / groupRow.length
    }
}
