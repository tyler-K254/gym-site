/**
 * DevExtreme (cjs/__internal/core/r1/template_wrapper.js)
 * Version: 23.2.6
 * Build date: Wed May 01 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildTemplateArgs = exports.TemplateWrapper = void 0;
var _inferno = require("@devextreme/runtime/inferno");
var _dom_adapter = _interopRequireDefault(require("../../../core/dom_adapter"));
var _element = require("../../../core/element");
var _renderer = _interopRequireDefault(require("../../../core/renderer"));
var _dom = require("../../../core/utils/dom");
var _type = require("../../../core/utils/type");
var _inferno2 = require("inferno");
var _shallow_equals = require("./utils/shallow_equals");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    }
}

function _assertThisInitialized(self) {
    if (void 0 === self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
    }
    return self
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}

function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key]
                }
            }
        }
        return target
    };
    return _extends.apply(this, arguments)
}
var __rest = (void 0, function(s, e) {
    var t = {};
    for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {
            t[p] = s[p]
        }
    }
    if (null != s && "function" === typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) {
                t[p[i]] = s[p[i]]
            }
        }
    }
    return t
});
const isDxElementWrapper = element => !!element.toArray;
const buildTemplateArgs = (model, template) => {
    var _a;
    const args = {
        template: template,
        model: _extends({}, model)
    };
    const _b = null !== (_a = model.data) && void 0 !== _a ? _a : {},
        {
            isEqual: isEqual
        } = _b,
        data = __rest(_b, ["isEqual"]);
    if (isEqual) {
        args.model.data = data;
        args.isEqual = isEqual
    }
    return args
};
exports.buildTemplateArgs = buildTemplateArgs;
const renderTemplateContent = (props, container) => {
    var _a;
    const {
        data: data,
        index: index
    } = null !== (_a = props.model) && void 0 !== _a ? _a : {
        data: {}
    };
    if (data) {
        Object.keys(data).forEach(name => {
            if (data[name] && _dom_adapter.default.isNode(data[name])) {
                data[name] = (0, _element.getPublicElement)((0, _renderer.default)(data[name]))
            }
        })
    }
    const rendered = props.template.render(_extends(_extends(_extends({
        container: container,
        transclude: props.transclude
    }, {
        renovated: props.renovated
    }), !props.transclude ? {
        model: data
    } : {}), !props.transclude && Number.isFinite(index) ? {
        index: index
    } : {}));
    if (void 0 === rendered) {
        return []
    }
    return (element = rendered, !!element.toArray) ? rendered.toArray() : [(0, _renderer.default)(rendered).get(0)];
    var element
};
const removeDifferentElements = (oldChildren, newChildren) => {
    newChildren.forEach(newElement => {
        const hasOldChild = !!oldChildren.find(oldElement => newElement === oldElement);
        if (!hasOldChild && newElement.parentNode) {
            (0, _renderer.default)(newElement).remove()
        }
    })
};
let TemplateWrapper = function(_InfernoComponent) {
    _inheritsLoose(TemplateWrapper, _InfernoComponent);

    function TemplateWrapper(props) {
        var _this;
        _this = _InfernoComponent.call(this, props) || this;
        _this.renderTemplate = _this.renderTemplate.bind(_assertThisInitialized(_this));
        return _this
    }
    var _proto = TemplateWrapper.prototype;
    _proto.renderTemplate = function() {
        const node = (0, _inferno2.findDOMfromVNode)(this.$LI, true);
        if (!(null === node || void 0 === node ? void 0 : node.parentNode)) {
            return () => {}
        }
        const container = node.parentNode;
        const $container = (0, _renderer.default)(container);
        const $oldContainerContent = $container.contents().toArray();
        const content = renderTemplateContent(this.props, (0, _element.getPublicElement)($container));
        (0, _dom.replaceWith)((0, _renderer.default)(node), (0, _renderer.default)(content));
        return () => {
            const $actualContainerContent = (0, _renderer.default)(container).contents().toArray();
            oldChildren = $oldContainerContent, newChildren = $actualContainerContent, void newChildren.forEach(newElement => {
                const hasOldChild = !!oldChildren.find(oldElement => newElement === oldElement);
                if (!hasOldChild && newElement.parentNode) {
                    (0, _renderer.default)(newElement).remove()
                }
            });
            var oldChildren, newChildren;
            container.appendChild(node)
        }
    };
    _proto.shouldComponentUpdate = function(nextProps) {
        const {
            template: template,
            model: model
        } = this.props;
        const {
            template: nextTemplate,
            model: nextModel,
            isEqual: isEqual
        } = nextProps;
        const equalityComparer = null !== isEqual && void 0 !== isEqual ? isEqual : _shallow_equals.shallowEquals;
        if (template !== nextTemplate) {
            return true
        }
        if (!(0, _type.isDefined)(model) || !(0, _type.isDefined)(nextModel)) {
            return model !== nextModel
        }
        const {
            data: data,
            index: index
        } = model;
        const {
            data: nextData,
            index: nextIndex
        } = nextModel;
        if (index !== nextIndex) {
            return true
        }
        return !equalityComparer(data, nextData)
    };
    _proto.createEffects = function() {
        return [new _inferno.InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])]
    };
    _proto.updateEffects = function() {
        this._effects[0].update([this.props.template, this.props.model])
    };
    _proto.componentWillUnmount = function() {};
    _proto.render = function() {
        return null
    };
    return TemplateWrapper
}(_inferno.InfernoComponent);
exports.TemplateWrapper = TemplateWrapper;
